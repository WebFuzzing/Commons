/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * A unique identifier for an operation. For example, in REST, it would be a HTTP endpoint, including  verb, e.g., 'GET:/users/{id}'.
 */
export type OperationId = string;
/**
 * A unique identifier for a test case. It could include its name and file location.
 */
export type TestCaseId = string;
export type HttpStatus = number | null;
/**
 * A relative path used to unique locate a test suite file.
 */
export type TestFilePath = string;

/**
 * Schema Definition for Web Fuzzing Commons Reports
 */
export interface WebFuzzingCommonsReport {
  /**
   * The schema version of WFC needed to use to validate and process this document.
   */
  schemaVersion: string;
  /**
   * The name of the tool used to create the test cases reported in this document.
   */
  toolName: string;
  /**
   * The version number of the used tool, e.g., 1.0.0.
   */
  toolVersion: string;
  /**
   * The timestamp of when this report file was created.
   */
  creationTime: string;
  faults: Faults;
  problemDetails: {
    rest?: RESTReport;
    [k: string]: unknown;
  };
  /**
   * The total number of test cases generated by the tool.
   */
  totalTests: number;
  /**
   * The list of relative paths (compared to this document) of all the generated test suite files.
   */
  testFilePaths: TestFilePath[];
  /**
   * Information on each generated test case.
   */
  testCases: TestCase[];
  /**
   * For how long, in seconds, the tool was running in total.
   */
  executionTimeInSeconds: number;
  /**
   * Extra, optional coverage information, collected by different tools.
   */
  extra?: Coverage[] | null;
  [k: string]: unknown;
}
export interface Faults {
  /**
   * The total number of potential faults identified in the generated test suites. Each fault is uniquely identified with its 'code' category and 'context'. Note that different tests can detect the same fault, and a test case can detect several different faults.
   */
  totalNumber: number;
  /**
   * Information on all the identified potential faults.
   */
  foundFaults: FoundFault[];
  [k: string]: unknown;
}
/**
 * Data-structure to represent found faults, based on operations (e.g., HTTP endpoints in REST, and methods in GraphQL and RPC) and which tests find faults in them.
 */
export interface FoundFault {
  operationId?: OperationId;
  testCaseId: TestCaseId;
  /**
   * @minItems 1
   */
  faultCategories: [FaultCategoryId, ...FaultCategoryId[]];
  [k: string]: unknown;
}
/**
 * A unique identifier for a fault type.
 */
export interface FaultCategoryId {
  /**
   * Identifying fault 'code', based on WFC classification.
   */
  code: number;
  /**
   * An optional context for the fault. The same fault type could be manifested in different ways, and we use this property to differentiate among them.
   */
  context?: string | null;
  [k: string]: unknown;
}
export interface RESTReport {
  /**
   * Total number of HTTP calls made in all the generated test cases given as output.   A test case could contain several HTTP calls, e.g., a POST followed by a GET and then a DELETE.
   */
  outputHttpCalls: number;
  /**
   * Total number of all HTTP calls made during the whole fuzzing session. If the fuzzing was left running for hours, millions of HTTP could have been made. The output generated tests will only contain a tiny subset of these evaluated calls.
   */
  evaluatedHttpCalls: number;
  /**
   * Unique ids of all the endpoints in the tested API.
   */
  endpointIds: OperationId[];
  /**
   * List of which HTTP status codes were covered, based on endpoints.
   */
  coveredHttpStatus: CoveredEndpoint[];
  [k: string]: unknown;
}
/**
 * Data-structure to represent which HTTP status code where covered on an endpoint by any of the generated tests.
 */
export interface CoveredEndpoint {
  endpointId: OperationId;
  testCaseId: TestCaseId;
  /**
   * As in a test case the same endpoint could be called more than once, here we report all of the obtained HTTP status codes. If for any reason a call does not return any response (e.g., the TCP connection   does timeout), then this HTTP status array would be either null or empty.
   *
   * @minItems 0
   */
  httpStatus: HttpStatus[] | null;
  [k: string]: unknown;
}
export interface TestCase {
  id?: TestCaseId;
  filePath?: TestFilePath;
  /**
   * The name of the test case, as it appears in the generated test file.
   */
  name?: string;
  /**
   * The line number in the generated test suite file where the code of this test case starts.
   */
  startLine?: number;
  /**
   * The line number in the generated test suite file where the code of this test case ends.
   */
  endLine?: number;
  [k: string]: unknown;
}
export interface Coverage {
  /**
   * The name of the tool used to collect and compute the coverage criteria.
   */
  toolName: string;
  criteria: CoverageCriterion[];
  [k: string]: unknown;
}
export interface CoverageCriterion {
  /**
   * The name of this coverage criterion.
   */
  name: string;
  /**
   * The number of testing targets for this criterion that were covered.
   */
  covered: number;
  /**
   * Optional number of all testing targets for this criterion. For some criteria, this number can be unknown.
   */
  total?: number | null;
  [k: string]: unknown;
}
